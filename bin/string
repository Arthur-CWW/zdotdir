#!/usr/bin/env zsh
#
# string
# A simple zsh version of fish's string command
#

function _string-lower() {
  # https://zsh.sourceforge.io/Doc/Release/Expansion.html#Parameter-Expansion-Flags
  # (L) Convert all letters in the result to upper case.
  [[ $# -gt 0 ]] || return 1
  local args=("${(L)@}")
  printf '%s\n' $args
}

function _string-upper() {
  # https://zsh.sourceforge.io/Doc/Release/Expansion.html#Parameter-Expansion-Flags
  # (U) Convert all letters in the result to upper case.
  [[ $# -gt 0 ]] || return 1
  local args=("${(U)@}")
  printf '%s\n' $args
}

function _string-before() {
  # prints the substring before a string
  # https://developer.mozilla.org/en-US/docs/Web/XPath/Functions/substring-before
  # https://zsh.sourceforge.io/Doc/Release/Expansion.html#Parameter-Expansion
  if [[ $# -lt 1 ]]; then
    echo >&2 "usage: string before <needle> <haystack>" && return 1
  fi
  local needle=$1; shift
  local item
  for item in $@; do
    echo ${item%%$needle*}
  done
}

function _string-after() {
  # prints the substring after a string
  # https://developer.mozilla.org/en-US/docs/Web/XPath/Functions/substring-after
  # https://zsh.sourceforge.io/Doc/Release/Expansion.html#Parameter-Expansion
  if [[ $# -lt 1 ]]; then
    echo >&2 "usage: string after <needle> <haystack>" && return 1
  fi
  local needle=$1; shift
  local item
  for item in $@; do
    echo ${item#*$needle}
  done
}

function _string-sub() {
  # prints the substring of a string
  local item newval positional _flag_quiet=false _flag_start=0 _flag_length=
  local usage=(
    "string-sub - extract substrings"
    "  string sub [(-s | --start) START] [(-l | --length) LENGTH] [(-q | --quiet)] [STRING...]"
  )
  opterr() { echo >&2 "Unknown option '$1'." }

  while (( $# )); do
    case $1 in
      --)              shift; positional+=("$@"); break  ;;
      -h|--help)       printf "%s\n" $usage && return    ;;
      -q|--quiet)      shift; _flag_quiet=true           ;;
      -s|--start)      shift; _flag_start=$1             ;;
      -s=*|--start=*)  _flag_start="${1#*=}"             ;;
      -l|--length)     shift; _flag_length=$1            ;;
      -l=*|--length=*) _flag_length="${1#*=}"            ;;
      -*)              opterr $1 && return 2             ;;
      *)               positional+=("$@"); break         ;;
    esac
    shift
  done
  for item in $positional; do
    if [[ -n "$_flag_length" ]]; then
      newval=${item:$_flag_start:$_flag_length}
    else
      newval=${item:$_flag_start}
    fi
    [[ $_flag_quiet = false ]] && echo $newval
  done
}

function _string() {
  local cmd=$1
  if (( $+functions[_string-${cmd}] )); then
    shift
    _string-${cmd} "$@"
    return $?
  else
    echo >&2 "The subcommand doesn't exist: '$1'."
    return 1
  fi
}
_string $@
